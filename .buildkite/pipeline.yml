# .buildkite/pipeline.yml
# Pipeline CI/CD - Lint, Version, and Security Scan
env:
  # ====================
  # VAULT CONFIGURATION
  # ====================
  VAULT_ADDR: "{{vault_addr}}"
  VAULT_AUTH_PATH: "jwt-buildkite"
  VAULT_AUTH_ROLE: "pipeline-ci"
  VAULT_NAMESPACE: "{{vault_namespace}}"
  
  # ====================
  # VERSIONING CONFIGURATION
  # ====================
  ENABLE_AUTO_BUMP: "true"
  VERSION_BUMP_BRANCH: "main"
  
  # ====================
  # SCANNING CONFIGURATION
  # ====================
  GITGUARDIAN_INSTANCE_URL: "https://api.gitguardian.com"

steps:
  # ============================================================================
  # PHASE 1: VALIDATION
  # ============================================================================
  
  - group: "ðŸ” Validation Phase"
    key: "validation-phase"
    steps:
      
      - label: ":yaml: Lint Buildkite Pipelines"
        key: "lint-pipelines"
        commands:
          - |
            $pipelineFiles = Get-ChildItem -Path ".buildkite" -Filter "*.yml" -Recurse
            $failed = $false
            
            foreach ($file in $pipelineFiles) {
              Write-Host "Validating $($file.FullName)..." -ForegroundColor Cyan
              buildkite-agent pipeline lint $file.FullName
              if ($LASTEXITCODE -ne 0) {
                Write-Host "âŒ $($file.Name) is invalid" -ForegroundColor Red
                $failed = $true
              } else {
                Write-Host "âœ… $($file.Name) is valid" -ForegroundColor Green
              }
            }
            
            if ($failed) { exit 1 }
        agents:
          queue: "windows"

      - label: ":json: Validate Pipeline Schema"
        key: "validate-schema"
        commands:
          - pip install check-jsonschema pyyaml --quiet
          - |
            $schemaUrl = "https://raw.githubusercontent.com/buildkite/pipeline-schema/main/schema.json"
            $pipelineFiles = Get-ChildItem -Path ".buildkite" -Filter "*.yml" -Recurse
            $failed = $false
            
            foreach ($file in $pipelineFiles) {
              Write-Host "Schema validation: $($file.Name)" -ForegroundColor Cyan
              check-jsonschema --schemafile $schemaUrl $file.FullName
              if ($LASTEXITCODE -ne 0) { $failed = $true }
            }
            
            if ($failed) { exit 1 }
        agents:
          queue: "windows"

      - label: ":conventional_commits: Validate Commits"
        key: "validate-commits"
        commands:
          - pip install commitizen --quiet
          - |
            # Get commits since last tag
            $lastTag = git describe --tags --abbrev=0 2>$null
            if ($lastTag) {
              Write-Host "Checking commits since $lastTag..." -ForegroundColor Cyan
              cz check --rev-range "$lastTag..HEAD"
            } else {
              Write-Host "No previous tag found, checking last 10 commits..." -ForegroundColor Yellow
              cz check --rev-range "HEAD~10..HEAD"
            }
        agents:
          queue: "windows"
        soft_fail: true

  # ============================================================================
  # PHASE 2: SECURITY SCANNING
  # ============================================================================
  
  - group: "ðŸ›¡ï¸ Security Phase"
    key: "security-phase"
    depends_on: "validation-phase"
    steps:
      
      - label: ":vault: Fetch Security Credentials"
        key: "fetch-security-creds"
        commands:
          - |
            # Request OIDC token from Buildkite
            $oidcToken = buildkite-agent oidc request-token --audience "$env:VAULT_ADDR"
            
            # Authenticate to Vault
            $authResponse = Invoke-RestMethod -Uri "$env:VAULT_ADDR/v1/auth/$env:VAULT_AUTH_PATH/login" `
              -Method POST `
              -ContentType "application/json" `
              -Body (@{ role = $env:VAULT_AUTH_ROLE; jwt = $oidcToken } | ConvertTo-Json)
            
            $vaultToken = $authResponse.auth.client_token
            $headers = @{ "X-Vault-Token" = $vaultToken }
            
            # Create secrets directory
            New-Item -ItemType Directory -Force -Path ".\\secrets" | Out-Null
            
            # Fetch GitGuardian API key
            $ggSecrets = Invoke-RestMethod -Uri "$env:VAULT_ADDR/v1/$env:VAULT_NAMESPACE/data/gitguardian" `
              -Headers $headers
            $ggSecrets.data.data | ConvertTo-Json | Out-File ".\\secrets\\gitguardian.json"
            
            Write-Host "âœ… Security credentials fetched" -ForegroundColor Green
        artifact_paths:
          - ".secrets/**/*"
        agents:
          queue: "windows"

      - label: ":gitguardian: GitGuardian Secret Scan"
        key: "gitguardian-scan"
        depends_on: "fetch-security-creds"
        commands:
          - pip install ggshield --quiet
          - buildkite-agent artifact download ".secrets/**/*" .
          - |
            # Load GitGuardian API key
            $ggCreds = Get-Content ".\\secrets\\gitguardian.json" | ConvertFrom-Json
            $env:GITGUARDIAN_API_KEY = $ggCreds.api_key
            
            Write-Host "Running GitGuardian scan..." -ForegroundColor Cyan
            
            # Full repository scan
            ggshield secret scan repo . --json > gitguardian-report.json
            
            # Check for incidents
            $report = Get-Content "gitguardian-report.json" | ConvertFrom-Json
            if ($report.total_incidents -gt 0) {
              Write-Host "âŒ Found $($report.total_incidents) secret(s) in repository!" -ForegroundColor Red
              ggshield secret scan repo .
              exit 1
            } else {
              Write-Host "âœ… No secrets detected" -ForegroundColor Green
            }
        artifact_paths:
          - "gitguardian-report.json"
        agents:
          queue: "windows"

      - label: ":gitguardian: Scan Commit Range"
        key: "gitguardian-commits"
        depends_on: "fetch-security-creds"
        commands:
          - pip install ggshield --quiet
          - buildkite-agent artifact download ".secrets/**/*" .
          - |
            $ggCreds = Get-Content ".\\secrets\\gitguardian.json" | ConvertFrom-Json
            $env:GITGUARDIAN_API_KEY = $ggCreds.api_key
            
            # Scan commits since last scan/tag
            $lastTag = git describe --tags --abbrev=0 2>$null
            if ($lastTag) {
              Write-Host "Scanning commits since $lastTag..." -ForegroundColor Cyan
              ggshield secret scan commit-range "$lastTag..HEAD"
            } else {
              Write-Host "Scanning last 50 commits..." -ForegroundColor Yellow
              ggshield secret scan commit-range "HEAD~50..HEAD"
            }
        agents:
          queue: "windows"

  # ============================================================================
  # PHASE 3: VERSIONING & CHANGELOG
  # ============================================================================
  
  - group: "ðŸ“¦ Versioning Phase"
    key: "versioning-phase"
    depends_on: "security-phase"
    steps:
      
      - label: ":cliff: Generate Changelog Preview"
        key: "changelog-preview"
        commands:
          - |
            # Install git-cliff
            cargo install git-cliff --quiet 2>$null
            if ($LASTEXITCODE -ne 0) {
              # Fallback: download binary
              $version = "2.4.0"
              $url = "https://github.com/orhun/git-cliff/releases/download/v$version/git-cliff-$version-x86_64-pc-windows-msvc.zip"
              Invoke-WebRequest -Uri $url -OutFile "git-cliff.zip"
              Expand-Archive -Path "git-cliff.zip" -DestinationPath "." -Force
            }
            
            # Generate changelog preview (unreleased changes)
            Write-Host "ðŸ“‹ Changelog Preview (Unreleased):" -ForegroundColor Cyan
            git-cliff --unreleased --strip header
            
            # Generate full changelog to file
            git-cliff -o CHANGELOG-PREVIEW.md
        artifact_paths:
          - "CHANGELOG-PREVIEW.md"
        agents:
          queue: "windows"

      - label: ":calculator: Calculate Next Version"
        key: "calculate-version"
        commands:
          - |
            # Install git-cliff
            $cliffPath = "git-cliff"
            if (-not (Get-Command git-cliff -ErrorAction SilentlyContinue)) {
              $version = "2.4.0"
              $url = "https://github.com/orhun/git-cliff/releases/download/v$version/git-cliff-$version-x86_64-pc-windows-msvc.zip"
              Invoke-WebRequest -Uri $url -OutFile "git-cliff.zip"
              Expand-Archive -Path "git-cliff.zip" -DestinationPath "." -Force
              $cliffPath = ".\\git-cliff-$version-x86_64-pc-windows-msvc\\git-cliff.exe"
            }
            
            # Get current version
            $currentTag = git describe --tags --abbrev=0 2>$null
            if (-not $currentTag) { $currentTag = "0.0.0" }
            $currentTag = $currentTag -replace "^v", ""
            
            Write-Host "Current version: $currentTag" -ForegroundColor Cyan
            
            # Calculate next version using git-cliff
            $nextVersion = & $cliffPath --bumped-version 2>$null
            if (-not $nextVersion) {
              # Fallback: parse commits manually
              $commits = git log "$currentTag..HEAD" --pretty=format:"%s" 2>$null
              
              $major = $false
              $minor = $false
              $patch = $false
              
              foreach ($commit in $commits) {
                if ($commit -match "^feat.*!:|^.*BREAKING CHANGE") { $major = $true }
                elseif ($commit -match "^feat") { $minor = $true }
                elseif ($commit -match "^fix|^perf|^refactor") { $patch = $true }
              }
              
              $parts = $currentTag -split "\."
              $majorV = [int]$parts[0]
              $minorV = [int]$parts[1]
              $patchV = [int]$parts[2]
              
              if ($major) { $majorV++; $minorV = 0; $patchV = 0 }
              elseif ($minor) { $minorV++; $patchV = 0 }
              elseif ($patch) { $patchV++ }
              else { $patchV++ }
              
              $nextVersion = "$majorV.$minorV.$patchV"
            }
            
            Write-Host "Next version: $nextVersion" -ForegroundColor Green
            
            # Save for later steps
            $nextVersion | Out-File "next-version.txt"
            
            # Set metadata for Buildkite UI
            buildkite-agent meta-data set "next-version" $nextVersion
            buildkite-agent annotate "**Next Version:** v$nextVersion" --style "info" --context "version"
        artifact_paths:
          - "next-version.txt"
        agents:
          queue: "windows"

  # ============================================================================
  # PHASE 4: RELEASE (Only on main branch)
  # ============================================================================
  
  - block: ":rocket: Create Release?"
    key: "approve-release"
    depends_on: "versioning-phase"
    prompt: "Create a new release with the calculated version?"
    if: build.branch == "main" && build.env("ENABLE_AUTO_BUMP") == "true"

  - label: ":git: Bump Version & Tag"
    key: "bump-version"
    depends_on: "approve-release"
    commands:
      - buildkite-agent artifact download "next-version.txt" .
      - buildkite-agent artifact download "CHANGELOG-PREVIEW.md" .
      - |
        $nextVersion = (Get-Content "next-version.txt").Trim()
        
        # Install git-cliff
        $version = "2.4.0"
        $url = "https://github.com/orhun/git-cliff/releases/download/v$version/git-cliff-$version-x86_64-pc-windows-msvc.zip"
        Invoke-WebRequest -Uri $url -OutFile "git-cliff.zip"
        Expand-Archive -Path "git-cliff.zip" -DestinationPath "." -Force
        $cliffPath = ".\\git-cliff-$version-x86_64-pc-windows-msvc\\git-cliff.exe"
        
        # Generate final changelog
        & $cliffPath --tag "v$nextVersion" -o CHANGELOG.md
        
        # Configure git
        git config user.name "Buildkite CI"
        git config user.email "ci@buildkite.com"
        
        # Commit changelog
        git add CHANGELOG.md
        git commit -m "chore(release): v$nextVersion [skip ci]" --allow-empty
        
        # Create annotated tag
        $tagMessage = & $cliffPath --unreleased --strip header
        git tag -a "v$nextVersion" -m "Release v$nextVersion`n`n$tagMessage"
        
        # Push changes
        git push origin HEAD:$env:BUILDKITE_BRANCH
        git push origin "v$nextVersion"
        
        Write-Host "âœ… Released v$nextVersion" -ForegroundColor Green
        buildkite-agent annotate "**Released:** v$nextVersion :rocket:" --style "success" --context "release"
    agents:
      queue: "windows"
    if: build.branch == "main"

  # ============================================================================
  # PHASE 5: NOTIFICATIONS
  # ============================================================================
  
  - label: ":slack: Notify Release"
    key: "notify-release"
    depends_on: "bump-version"
    allow_dependency_failure: false
    commands:
      - buildkite-agent artifact download "next-version.txt" .
      - |
        $version = (Get-Content "next-version.txt").Trim()
        $repo = $env:BUILDKITE_REPO -replace ".*[:/](.*/.*?)(?:\.git)?$", '$1'
        
        # You can add Slack/Teams webhook notification here
        Write-Host "ðŸ“¢ Notifying release of v$version for $repo"
    agents:
      queue: "windows"
    if: build.branch == "main"
